/*
* Part of the Aeon Framework
* -----------------------------------------------------------------------------
* Aeon Expat XML Wrapper.
*
* File:		SAXParser.h
  Desc.:	SAXParser class definition.
* Author:	Felix Bruckner <xography@gatewayheaven.com>
*
* Copyright (c) 2009-2010, gatewayheaven.com. 
* Licensed under the Boost Software License.
*
* -----------------------------------------------------------------------------
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
* -----------------------------------------------------------------------------
*/
#ifndef _SAXParser_h_
#define _SAXParser_h_

#include "AeonXMLFwd.h"

#include "AeonXMLConf.h"
#include <exception>

#include <iosfwd>
#include <stdio.h>
#include <string>

#include <stddef.h>
#include "expat.h"

#if AEON_PLATFORM == AEON_WIN32
#include <windows.h>
	typedef SSIZE_T ssize_t;
#endif

namespace Aeon {
	typedef char XML_Char;
	// Quick Exception class
	// Note: I'm not using the Framework's Exception class to enable stand-alone
	// usage of the XML Parser Wrapper
	class SAXParserException : public std::exception {
	public:
		// Constructor which accepts own error descriptions
		explicit SAXParserException(const std::string &desc) : description(desc) {}
		virtual ~SAXParserException() throw() {}
		
		// Overriding the std::exception what
		const char* what() const throw() { 
			return description.c_str();
		}
	private:
		std::string description;
	}; // class SAXParserException

	class SAXParser {
	public:
		/**
		 * Creates a new Parser, sets up all required Handlers via bootstrapping
		 * the System.
		 *
		 * @param handler The SAX Event Handler.
		 */ 
		SAXParser(Aeon::SAXHandlerInterface* handler);

		/**
		 * Creates a new Parser, sets up all required Handlers via bootstrapping
		 * the System with a user-defined chunk size; the Chunk Size is the buffer
		 * used while stream-reading the file.
		 *
		 * @param handler The SAX Event Handler class, must implement the 
		 * SAXHandlerInterface or any Adapter.
		 * @param chunkSize Buffer size to use while reading parsing the filestream.
		 *
		 */ 
		SAXParser(Aeon::SAXHandlerInterface* handler, size_t chunkSize);
		virtual ~SAXParser();

		/**
		 * Parses the given file. Throws SAXParserException if anything crucial
		 * goes wrong, so should surround the statement with try catch.
		 *
		 * @param filename
		 * @return false if anything goes wrong, true if the end of the file
		 * was reached without any errors.
		 */ 
		virtual bool parse(const std::string& filename);

		virtual void parseString(const std::string& str);
		
		/**
		 * Get the current Expat Error Code, XML_ERROR. Refer to the Expat manual 
		 * for interpretation of the specific codes
		 * 
		 * @return the Error Code.
		 */ 
		virtual XML_Error xmlError();
		
		/**
		 * The parser's current status, should be XML_STATUS_OK while parsing,
		 * XML_STATUS_ERROR means there is something quite wrong.
		 *
		 * @return The parser's current status.
		  */ 
		virtual XML_Status xmlStatus();

		/**
		 * Check whether the parser is ready to start parsing, useful for checking
		 * if there was anything going wrong during initialization.
		 * 
		 * @return whether the parser is ready to start parsing.
		 */ 
		virtual bool isReady();

		/**
		 * Returns the Last error which occurred with the accompanying description
		 * taken from the Expat library.
		 *
		 * @return description of the last error.
		 */ 
		virtual std::string xmlErrorString();

	private:
		Aeon::SAXHandlerInterface* _handler;
		XML_Parser	_parser;
		XML_Error	_error;
		XML_Status	_status;

		XML_Char* _buffer;
		size_t	_bufsize;

		bool _ready;
		
		// To keep track of any failures during initalization
		bool _failure;
	
		// Used to initalized the parser
		void bootstrap();

		// Reads a block from _file
		ssize_t _readblock();

		FILE *_file;
		std::string _fname;
		
		//---------------------------------------------------------------------
		// Static handlers

		// XML Elements & Attributes
		static void _handleElementStart(void *userData,
			const XML_Char *name, const XML_Char **atts);
		static void _handleElementEnd(void *userData,
			const XML_Char *name);
		// Character Data
		static void _handleCharacterData(void *userData,
			const XML_Char *s, int len);
		// Processing Instructions
		static void _handleProcessingInstruction(void *userData,
			const XML_Char *target, const XML_Char *data);
		// Comments
		static void _handleComments(void *userData,
			const XML_Char *data);
		// Default Handler
		static void _handleDefault(void *userData,
			const XML_Char *s, int len);
		// CDATA
		static void _handleCDATAStart(void *userData);
		static void _handleCDATAEnd(void *userData);
		// DOCTYPE 
		static void _handleDoctypeDeclStart(void* userData, 
			const XML_Char* doctypeName, const XML_Char *systemId, 
			const XML_Char* publicId, int hasInternalSubset);
		static void _handleDoctypeDeclEnd(void* userData);
		// Notations
		static void _handleNotationDecl(void* userData, 
			const XML_Char* notationName, const XML_Char* base, 
			const XML_Char* systemId, const XML_Char* publicId);

		// Namespaces
		static void _handleStartNamespaceDecl(void* userData, 
			const XML_Char* prefix, const XML_Char* uri);
		static void _handleEndNamespaceDecl(void* userData, 
			const XML_Char* prefix);
		// Entity Handlers
		static void _handleEntityDecl(void *userData, 
			const XML_Char *entityName, int isParamEntity, 
			const XML_Char *value, int valueLength, 
			const XML_Char *base, const XML_Char *systemId, 
			const XML_Char *publicId, const XML_Char *notationName);

		static void _handleSkippedEntity(void* userData, 
			const XML_Char* entityName, int isParameterEntity);

		static void _handleUnparsedEntityDecl(void* userData, 
			const XML_Char* entityName, const XML_Char* base, 
			const XML_Char* systemId, const XML_Char* publicId, 
			const XML_Char* notationName);


	};

	

}

#endif
